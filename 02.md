# 无模块化标准阶段 
  * 文件划分：
     1. 模块变量相当于在全局声明和定义，会有变量名冲突的问题

     2. 由于变量都在全局生命和定义我们很难知道某个变量到底属于哪个模块 
     3. 无法清晰的管理模块之间的依赖关系和加载顺序
  * 命名空间（window.a  window.b）
      1. 相当于挂在全局window属性上，
      2. 缺点：如果有相同的命名 后者会覆盖掉前者
  * IIFE(立即执行函数)
     1. 如果模块间存在依赖关系，那么 script 标签的加载顺序就需要受到严格的控制，一旦顺序不对，则很有可能产生运行时 Bug。
   
   # 模块化标准阶段
 * CommonJS规范
   1. 统一的模块化规范
   2. 实现自动加载模块的加载器（也成loader）
   3. 缺点： 
       1. 模块器是由Nodejs提供的，依赖了nodejs本身的功能实现，比如系统文件，commonjs直接放在浏览器是无法执行成功的，需要借助社区实现的 browserify打包工具·
       2. commonjs是同步加载的，不太适用于浏览器，在浏览器使用commonjs会造成浏览器 JS 解析过程的阻塞，从而导致页面加载速度缓慢。
* AMD 规范（异步模块定义规范）
  在浏览器环境中会被异步加载，而不会像 CommonJS 规范进行同步加载，不会产生浏览器解析阻塞的问题
    * 缺点：
     1. 由于没有得到浏览器的原生支持，AMD 规范需要由第三方的 loader 来实现，最经典的就是 requireJS 库了，它完整实现了 AMD 规范，至今仍然有不少项目在使用

* CMD 规范 （由taobao出品基本上和amd规范一样）
* UMD 规范 
     1. 兼容 AMD 和 CommonJS 的一个模块化方案，可以同时运行在浏览器和 Node.js 环境 ESM也具备相同的能力

* ESM (ES6 module)

在nodeJs中你可以在package.json 中声明 type:'module'属性 nodeJS就会默认以ESModule去解析

```js
{
  "type":"module"
}
```

在 Node.js 中，即使是在 CommonJS 模块里面，也可以通过 import 方法顺利加载 ES 模块